name: Reusable Deploy to Pantheon DEV

on:
  workflow_call:
    inputs:
      pantheon_site:
        description: 'Pantheon site name'
        required: true
        type: string
      target_env:
        description: 'Target environment (default: dev)'
        required: false
        type: string
        default: 'dev'
      backup_hours_threshold:
        description: 'Hours threshold for backup check (default: 6)'
        required: false
        type: number
        default: 6
      run_semantic_release:
        description: 'Whether to run semantic release first'
        required: false
        type: boolean
        default: true
    secrets:
      PANTHEON_SSH_KEY:
        required: true
      PANTHEON_MACHINE_TOKEN:
        required: true
      CI_GH_TOKEN:
        required: false

defaults:
  run:
    shell: bash

jobs:
  semantic_release:
    name: Semantic Release
    if: ${{ inputs.run_semantic_release }}
    runs-on: ubuntu-latest
    environment:
      name: Production
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          # Ensure we checkout the target branch, not the PR branch
          ref: ${{ github.event.pull_request.base.ref || github.ref }}
          fetch-depth: 0
      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install semantic-release
        run: |
          npm install semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github @semantic-release/commit-analyzer @semantic-release/release-notes-generator

      - name: Configure Git for semantic-release
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create semantic-release configuration
        run: |
          cat > package.json << 'EOF'
          {
            "name": "semantic-release-config",
            "private": true,
            "release": {
              "branches": ["master", "main"],
              "plugins": [
                "@semantic-release/commit-analyzer",
                "@semantic-release/release-notes-generator",
                "@semantic-release/changelog",
                "@semantic-release/github",
                [
                  "@semantic-release/git",
                  {
                    "assets": ["CHANGELOG.md"],
                    "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
                  }
                ]
              ]
            }
          }
          EOF

      - name: Run semantic-release with forced context
        run: |
          # Set environment to simulate a push to the target branch
          export GITHUB_EVENT_NAME=push
          export GITHUB_REF=refs/heads/${{ github.event.pull_request.base.ref || github.ref_name }}
          export GITHUB_HEAD_REF=""
          export GITHUB_BASE_REF=""
          export CI_PULL_REQUEST=""

          echo "Running semantic-release with simulated push context"
          echo "Target branch: ${{ github.event.pull_request.base.ref || github.ref_name }}"
          echo "GitHub ref: $GITHUB_REF"

          npx semantic-release --debug
        env:
          GITHUB_TOKEN: ${{ secrets.CI_GH_TOKEN }}

  deploy_to_pantheon:
    name: Deploy To ${{ inputs.target_env }}
    needs: semantic_release
    if: ${{ always() && (needs.semantic_release.result == 'success' || needs.semantic_release.result == 'skipped') }}
    permissions:
      deployments: write
      contents: write
      pull-requests: read
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        # Ensure we checkout the target branch (master/main) for deployment
        ref: ${{ github.event.pull_request.base.ref || github.ref }}
        # Use shallow clone to let pantheon action handle unshallowing
        fetch-depth: 1

    - name: deploy to Pantheon
      uses: pantheon-systems/push-to-pantheon@0.7.0
      with:
        ssh_key: ${{ secrets.PANTHEON_SSH_KEY }}
        machine_token: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
        site: ${{ inputs.pantheon_site }}
        target_env: ${{ inputs.target_env }}
        git_user_name: ${{ github.event.pull_request.user.login || github.actor }}
        git_user_email: ${{ github.event.pull_request.user.email || format('{0}@users.noreply.github.com', github.actor) }}
        git_commit_message: "Automated deployment from GitHub Actions"
        delete_old_environments: false
        clone_content: false

    - name: Check for last backup
      id: last_backup
      env:
        TERMINUS_MACHINE_TOKEN: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
      run: |
        # Get a list of timestamps
        last_timestamp=$(terminus backup:info --element database --format list --field date ${{ inputs.pantheon_site }}.live)

        # Get the timestamp from the list element
        last_epoch="${last_timestamp%%.*}"

        # Get current epoch time
        current_epoch=$(date +%s)

        # Calculate difference in seconds
        time_diff=$((current_epoch - last_epoch))

        # Convert hours to seconds
        hours_calc=$((${{ inputs.backup_hours_threshold }} * 3600))

        # Check if difference is more than threshold
        if [ $time_diff -gt $hours_calc ]; then
          echo "The last backup was: $((time_diff / 3600)) hours ago, we need a new one."
          echo "needs_backup=true" >> $GITHUB_OUTPUT
        else
          echo "needs_backup=false" >> $GITHUB_OUTPUT
        fi

    - name: Create backup on live
      if: ${{ steps.last_backup.outputs.needs_backup == 'true' }}
      env:
        TERMINUS_MACHINE_TOKEN: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
      run: |
        echo "Creating backup on live"
        terminus -n drush ${{ inputs.pantheon_site }}.live -- cr
        terminus -n backup:create "${{ inputs.pantheon_site }}.live" --keep-for=30 --no-interaction --quiet --yes

    - name: Run config imports and db updates
      env:
        TERMINUS_MACHINE_TOKEN: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
      run: |
        terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- updb -y
        terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- cim -y
        terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- cr -y