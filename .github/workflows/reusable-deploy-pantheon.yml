name: Reusable Deploy to Pantheon DEV

on:
  workflow_call:
    inputs:
      pantheon_site:
        description: 'Pantheon site name'
        required: true
        type: string
      target_env:
        description: 'Target environment (default: dev)'
        required: false
        type: string
        default: 'dev'
      backup_hours_threshold:
        description: 'Hours threshold for backup check (default: 6)'
        required: false
        type: number
        default: 6
      run_semantic_release:
        description: 'Whether to run semantic release first'
        required: false
        type: boolean
        default: true
      slack_channel:
        description: 'Slack channel for notifications (e.g., #deployments)'
        required: false
        type: string
      workflow_skip_terminus:
        description: 'Skip post-deployment Terminus commands (database updates, config import, cache rebuild)'
        required: false
        type: boolean
        default: false
    secrets:
      PANTHEON_SSH_KEY:
        required: true
      PANTHEON_MACHINE_TOKEN:
        required: true
      CI_GH_TOKEN:
        required: false
      SLACK_BOT_TOKEN:
        required: false

defaults:
  run:
    shell: bash

jobs:
  semantic_release:
    name: Semantic Release
    if: ${{ inputs.run_semantic_release }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          # Ensure we checkout the target branch, not the PR branch
          ref: ${{ github.event.pull_request.base.ref || github.ref }}
          fetch-depth: 0
      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install semantic-release
        run: |
          npm install semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github @semantic-release/commit-analyzer @semantic-release/release-notes-generator

      - name: Configure Git for semantic-release
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create semantic-release configuration
        run: |
          cat > package.json << 'EOF'
          {
            "name": "semantic-release-config",
            "private": true,
            "release": {
              "branches": ["master", "main"],
              "plugins": [
                "@semantic-release/commit-analyzer",
                "@semantic-release/release-notes-generator",
                "@semantic-release/changelog",
                [
                  "@semantic-release/github",
                  {
                    "successComment": false,
                    "failComment": false,
                    "failTitle": false,
                    "labels": false,
                    "releasedLabels": false,
                    "addReleases": "bottom",
                    "assets": false
                  }
                ],
                [
                  "@semantic-release/git",
                  {
                    "assets": ["CHANGELOG.md"],
                    "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
                  }
                ]
              ]
            }
          }
          EOF

      - name: Run semantic-release with forced context
        run: |
          # Check if we have a GitHub token
          if [[ -z "$GITHUB_TOKEN" ]]; then
            echo "::error::GITHUB_TOKEN is not set. Please provide CI_GH_TOKEN secret or ensure GITHUB_TOKEN has contents:write permission."
            exit 1
          fi

          # Set environment to simulate a push to the target branch
          export GITHUB_EVENT_NAME=push
          export GITHUB_REF=refs/heads/${{ github.event.pull_request.base.ref || github.ref_name }}
          export GITHUB_HEAD_REF=""
          export GITHUB_BASE_REF=""
          export CI_PULL_REQUEST=""

          echo "Running semantic-release with simulated push context"
          echo "Target branch: ${{ github.event.pull_request.base.ref || github.ref_name }}"
          echo "GitHub ref: $GITHUB_REF"

          npx semantic-release --debug
        env:
          GITHUB_TOKEN: ${{ secrets.CI_GH_TOKEN || github.token }}

  deploy_to_pantheon:
    name: Deploy To ${{ inputs.target_env }}
    needs: semantic_release
    if: ${{ always() && (needs.semantic_release.result == 'success' || needs.semantic_release.result == 'skipped') }}
    permissions:
      deployments: write
      contents: write
      pull-requests: read
    runs-on: ubuntu-latest
    outputs:
      env_url: ${{ steps.env_url.outputs.url }}
      error_message: ${{ steps.capture_error.outputs.error_message }}
      failed_step: ${{ steps.capture_error.outputs.failed_step }}
    steps:
    - uses: actions/checkout@v4
      with:
        # Ensure we checkout the target branch (master/main) for deployment
        ref: ${{ github.event.pull_request.base.ref || github.ref }}
        # Use shallow clone to let pantheon action handle unshallowing
        fetch-depth: 1

    - name: deploy to Pantheon
      id: deploy_pantheon
      uses: pantheon-systems/push-to-pantheon@0.7.0
      with:
        ssh_key: ${{ secrets.PANTHEON_SSH_KEY }}
        machine_token: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
        site: ${{ inputs.pantheon_site }}
        target_env: ${{ inputs.target_env }}
        git_user_name: ${{ github.event.pull_request.user.login || github.actor }}
        git_user_email: ${{ github.event.pull_request.user.email || format('{0}@users.noreply.github.com', github.actor) }}
        git_commit_message: "Automated deployment from GitHub Actions"
        delete_old_environments: false
        clone_content: false

    - name: Check for last backup
      id: last_backup
      env:
        TERMINUS_MACHINE_TOKEN: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
      run: |
        # Check if live environment exists
        if terminus env:info ${{ inputs.pantheon_site }}.live --field=id 2>/dev/null; then
          echo "Live environment exists, checking for backups..."

          # Get a list of timestamps
          last_timestamp=$(terminus backup:info --element database --format list --field date ${{ inputs.pantheon_site }}.live)

          # Get the timestamp from the list element
          last_epoch="${last_timestamp%%.*}"

          # Get current epoch time
          current_epoch=$(date +%s)

          # Calculate difference in seconds
          time_diff=$((current_epoch - last_epoch))

          # Convert hours to seconds
          hours_calc=$((${{ inputs.backup_hours_threshold }} * 3600))

          # Check if difference is more than threshold
          if [ $time_diff -gt $hours_calc ]; then
            echo "The last backup was: $((time_diff / 3600)) hours ago, we need a new one."
            echo "needs_backup=true" >> $GITHUB_OUTPUT
          else
            echo "needs_backup=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "Live environment does not exist, skipping backup check."
          echo "needs_backup=false" >> $GITHUB_OUTPUT
        fi

    - name: Create backup on live
      id: create_backup
      if: ${{ steps.last_backup.outputs.needs_backup == 'true' }}
      env:
        TERMINUS_MACHINE_TOKEN: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
      run: |
        echo "Creating backup on live"
        terminus -n drush ${{ inputs.pantheon_site }}.live -- cr
        terminus -n backup:create "${{ inputs.pantheon_site }}.live" --keep-for=30 --no-interaction --quiet --yes

    - name: Run config imports and db updates
      if: ${{ !inputs.workflow_skip_terminus }}
      id: drush_commands
      env:
        TERMINUS_MACHINE_TOKEN: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
      run: |
        # Check PR title first, then commit message for order preference
        # Use HERE document to safely handle all special characters
        read -r -d '' COMMIT_MSG <<'EOF' || true
        ${{ github.event.pull_request.title || github.event.head_commit.message }}
        EOF

        if [[ "$COMMIT_MSG" == *"[config-first]"* ]]; then
          echo "ðŸ”§ Running config import first (detected [config-first] tag)"
          terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- cim -y
          terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- updb -y
        else
          echo "ðŸ”§ Running database update first (default order)"
          terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- updb -y
          terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- cim -y
        fi

        # Always run cache rebuild last
        terminus -n drush ${{ inputs.pantheon_site }}.${{ inputs.target_env }} -- cr -y

    - name: Get environment URL
      id: env_url
      env:
        TERMINUS_MACHINE_TOKEN: ${{ secrets.PANTHEON_MACHINE_TOKEN }}
      run: |
        URL=$(terminus env:view ${{ inputs.pantheon_site }}.${{ inputs.target_env }} --print)
        echo "url=$URL" >> $GITHUB_OUTPUT
        echo "Environment available at: $URL"

    - name: Capture error information
      id: capture_error
      if: ${{ failure() }}
      run: |
        # Determine which step failed and capture relevant error info
        if [[ "${{ steps.deploy_pantheon.conclusion }}" == "failure" ]]; then
          echo "failed_step=Pantheon Deployment" >> $GITHUB_OUTPUT
          echo "error_message=Failed to deploy to Pantheon. Check the deployment logs for details." >> $GITHUB_OUTPUT
        elif [[ "${{ steps.last_backup.conclusion }}" == "failure" ]]; then
          echo "failed_step=Backup Check" >> $GITHUB_OUTPUT
          echo "error_message=Failed to check or create backup on live environment." >> $GITHUB_OUTPUT
        elif [[ "${{ steps.create_backup.conclusion }}" == "failure" ]]; then
          echo "failed_step=Backup Creation" >> $GITHUB_OUTPUT
          echo "error_message=Failed to create backup on live environment." >> $GITHUB_OUTPUT
        elif [[ "${{ steps.drush_commands.conclusion }}" == "failure" ]]; then
          echo "failed_step=Drush Commands" >> $GITHUB_OUTPUT
          echo "error_message=Failed to run database updates, config import, or cache rebuild." >> $GITHUB_OUTPUT
        elif [[ "${{ steps.env_url.conclusion }}" == "failure" ]]; then
          echo "failed_step=Environment URL" >> $GITHUB_OUTPUT
          echo "error_message=Failed to retrieve environment URL from Pantheon." >> $GITHUB_OUTPUT
        else
          echo "failed_step=Unknown" >> $GITHUB_OUTPUT
          echo "error_message=Deployment failed at an unknown step. Check the workflow logs." >> $GITHUB_OUTPUT
        fi

  notify_slack:
    name: Notify Slack
    needs: [semantic_release, deploy_to_pantheon]
    if: ${{ always() && inputs.slack_channel }}
    runs-on: ubuntu-latest
    steps:
    - name: Determine deployment status
      id: status
      run: |
        semantic_result="${{ needs.semantic_release.result }}"
        deploy_result="${{ needs.deploy_to_pantheon.result }}"

        if [[ "$deploy_result" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "color=good" >> $GITHUB_OUTPUT
          echo "emoji=:white_check_mark:" >> $GITHUB_OUTPUT
        elif [[ "$deploy_result" == "failure" ]]; then
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "color=danger" >> $GITHUB_OUTPUT
          echo "emoji=:x:" >> $GITHUB_OUTPUT
        elif [[ "$deploy_result" == "cancelled" ]]; then
          echo "status=cancelled" >> $GITHUB_OUTPUT
          echo "color=warning" >> $GITHUB_OUTPUT
          echo "emoji=:warning:" >> $GITHUB_OUTPUT
        else
          echo "status=unknown" >> $GITHUB_OUTPUT
          echo "color=#808080" >> $GITHUB_OUTPUT
          echo "emoji=:question:" >> $GITHUB_OUTPUT
        fi

    - name: Send Slack notification
      if: ${{ always() }}
      run: |
        # Determine status and message
        if [[ "${{ needs.deploy_to_pantheon.result }}" == "success" ]]; then
          STATUS_EMOJI=":white_check_mark:"
          STATUS_COLOR="good"
          STATUS_TEXT="Success"
        elif [[ "${{ needs.deploy_to_pantheon.result }}" == "failure" ]]; then
          STATUS_EMOJI=":x:"
          STATUS_COLOR="danger"
          STATUS_TEXT="Failed"
        elif [[ "${{ needs.deploy_to_pantheon.result }}" == "cancelled" ]]; then
          STATUS_EMOJI=":warning:"
          STATUS_COLOR="warning"
          STATUS_TEXT="Cancelled"
        else
          STATUS_EMOJI=":question:"
          STATUS_COLOR="#808080"
          STATUS_TEXT="Unknown"
        fi

        # Build the message
        ENV_URL_FIELD=""
        if [[ "${{ needs.deploy_to_pantheon.result }}" == "success" && -n "${{ needs.deploy_to_pantheon.outputs.env_url }}" ]]; then
          ENV_URL_FIELD=",{\"title\": \"Environment URL\", \"value\": \"<${{ needs.deploy_to_pantheon.outputs.env_url }}|${{ needs.deploy_to_pantheon.outputs.env_url }}>\", \"short\": false}"
        fi

        # Add error information if deployment failed
        ERROR_FIELD=""
        if [[ "${{ needs.deploy_to_pantheon.result }}" == "failure" ]]; then
          FAILED_STEP="${{ needs.deploy_to_pantheon.outputs.failed_step }}"
          ERROR_MSG="${{ needs.deploy_to_pantheon.outputs.error_message }}"
          if [[ -n "$FAILED_STEP" && -n "$ERROR_MSG" ]]; then
            # Properly escape JSON values using jq
            FAILED_STEP_ESCAPED=$(echo "$FAILED_STEP" | jq -Rs .)
            ERROR_MSG_ESCAPED=$(echo "$ERROR_MSG" | jq -Rs .)
            ERROR_FIELD=",{\"title\": \"Failed Step\", \"value\": ${FAILED_STEP_ESCAPED}, \"short\": true},{\"title\": \"Error Details\", \"value\": ${ERROR_MSG_ESCAPED}, \"short\": false}"
          else
            ERROR_FIELD=",{\"title\": \"Error Details\", \"value\": \"Deployment failed. Check the workflow logs for more details.\", \"short\": false}"
          fi
        fi

        # Send to Slack using Bot API
        if [[ -n "${{ secrets.SLACK_BOT_TOKEN }}" ]]; then
          curl -X POST -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
            -H 'Content-type: application/json; charset=utf-8' \
            --data "{
              \"channel\": \"${{ inputs.slack_channel }}\",
              \"text\": \"${STATUS_EMOJI} Deployment ${STATUS_TEXT}\",
              \"attachments\": [
                {
                  \"color\": \"${STATUS_COLOR}\",
                  \"fields\": [
                    {
                      \"title\": \"Repository\",
                      \"value\": \"${{ github.repository }}\",
                      \"short\": true
                    },
                    {
                      \"title\": \"Environment\",
                      \"value\": \"${{ inputs.target_env }}\",
                      \"short\": true
                    },
                    {
                      \"title\": \"Site\",
                      \"value\": \"${{ inputs.pantheon_site }}\",
                      \"short\": true
                    },
                    {
                      \"title\": \"Status\",
                      \"value\": \"${STATUS_TEXT}\",
                      \"short\": true
                    },
                    {
                      \"title\": \"Workflow\",
                      \"value\": \"<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>\",
                      \"short\": false
                    }
                    ${ENV_URL_FIELD}
                    ${ERROR_FIELD}
                  ],
                  \"footer\": \"GitHub Actions\",
                  \"ts\": $(date +%s)
                }
              ]
            }" \
            https://slack.com/api/chat.postMessage
        else
          echo "SLACK_BOT_TOKEN not provided, skipping Slack notification"
        fi